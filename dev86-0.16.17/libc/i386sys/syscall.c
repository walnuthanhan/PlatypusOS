/* Copyright (C) 1995,1996 Robert de Bath <rdebath@cix.compulink.co.uk>
 * This file is part of the Linux-8086 C library and is distributed
 * under the GNU Library General Public License.
 * 
 * This file is automatically generated */

/* Standard start */


#ifndef __MSDOS__
#ifdef __AS386_32__
#asm
  .text
  .align 4
#endasm

/* CALL exit                    1   1	* */

#ifdef L___exit
#asm
export ___exit
___exit:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#1
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL fork                    2   0 */

#ifdef L_fork
#asm
export _fork
_fork:
  mov   eax,#2
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL vfork                   2   0	. fake alias of fork */

#ifdef L_vfork
#asm
export _vfork
_vfork:
  mov   eax,#2
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL read                    3   3 */

#ifdef L_read
#asm
export _read
_read:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#3
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL write                   4   3 */

#ifdef L_write
#asm
export _write
_write:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#4
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL open                    5   3 */

#ifdef L_open
#asm
export _open
_open:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#5
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL close                   6   1 */

#ifdef L_close
#asm
export _close
_close:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#6
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL waitpid                 7   3 */

#ifdef L_waitpid
#asm
export _waitpid
_waitpid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#7
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL creat                   8   2 */

#ifdef L_creat
#asm
export _creat
_creat:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#8
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL link                    9   2 */

#ifdef L_link
#asm
export _link
_link:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#9
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL unlink                  10  1 */

#ifdef L_unlink
#asm
export _unlink
_unlink:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#10
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL execve                  11  3 */

#ifdef L_execve
#asm
export _execve
_execve:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#11
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL chdir                   12  1 */

#ifdef L_chdir
#asm
export _chdir
_chdir:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#12
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL time                    13  1 */

#ifdef L_time
#asm
export _time
_time:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#13
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL dv32_mknod              14  3	* has correct args for 32bit dev_t */

#ifdef L___dv32_mknod
#asm
export ___dv32_mknod
___dv32_mknod:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#14
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL chmod                   15  2 */

#ifdef L_chmod
#asm
export _chmod
_chmod:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#15
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL chown                   16  3 */

#ifdef L_chown
#asm
export _chown
_chown:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#16
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL lseek                   19  3 */

#ifdef L_lseek
#asm
export _lseek
_lseek:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#19
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getpid                  20  0 */

#ifdef L_getpid
#asm
export _getpid
_getpid:
  mov   eax,#20
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL mount                   21  5 */

#ifdef L_mount
#asm
export _mount
_mount:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
  push  esi
  mov   esi,[esp+16]
  push  edi
  mov   edi,[esp+24]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
  push  esi
  mov   esi,[esp+20]
  push  edi
  mov   edi,[esp+28]
#endif
  mov   eax,#21
  int   $80
  pop   edi
  pop   esi
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL umount                  22  1 */

#ifdef L_umount
#asm
export _umount
_umount:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#22
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setuid                  23  1 */

#ifdef L_setuid
#asm
export _setuid
_setuid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#23
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getuid                  24  0 */

#ifdef L_getuid
#asm
export _getuid
_getuid:
  mov   eax,#24
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL stime                   25  1 */

#ifdef L_stime
#asm
export _stime
_stime:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#25
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL ptrace                  26  4 */

#ifdef L_ptrace
#asm
export _ptrace
_ptrace:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
  push  esi
  mov   esi,[esp+16]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
  push  esi
  mov   esi,[esp+20]
#endif
  mov   eax,#26
  int   $80
  pop   esi
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL alarm                   27  1 */

#ifdef L_alarm
#asm
export _alarm
_alarm:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#27
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL pause                   29  0 */

#ifdef L_pause
#asm
export _pause
_pause:
  mov   eax,#29
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL utime                   30  2 */

#ifdef L_utime
#asm
export _utime
_utime:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#30
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL access                  33  2 */

#ifdef L_access
#asm
export _access
_access:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#33
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL nice                    34  1 */

#ifdef L_nice
#asm
export _nice
_nice:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#34
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL ftime                   35  1 */

#ifdef L_ftime
#asm
export _ftime
_ftime:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#35
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sync                    36  0 */

#ifdef L_sync
#asm
export _sync
_sync:
  mov   eax,#36
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL kill                    37  2 */

#ifdef L_kill
#asm
export _kill
_kill:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#37
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL rename                  38  2 */

#ifdef L_rename
#asm
export _rename
_rename:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#38
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL mkdir                   39  2 */

#ifdef L_mkdir
#asm
export _mkdir
_mkdir:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#39
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL rmdir                   40  1 */

#ifdef L_rmdir
#asm
export _rmdir
_rmdir:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#40
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL dup                     41  1 */

#ifdef L_dup
#asm
export _dup
_dup:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#41
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL pipe                    42  1 */

#ifdef L_pipe
#asm
export _pipe
_pipe:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#42
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL times                   43  1 */

#ifdef L_times
#asm
export _times
_times:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#43
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setgid                  46  1 */

#ifdef L_setgid
#asm
export _setgid
_setgid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#46
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getgid                  47  0 */

#ifdef L_getgid
#asm
export _getgid
_getgid:
  mov   eax,#47
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL signal                  48  2 */

#ifdef L_signal
#asm
export _signal
_signal:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#48
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL geteuid                 49  0 */

#ifdef L_geteuid
#asm
export _geteuid
_geteuid:
  mov   eax,#49
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getegid                 50  0 */

#ifdef L_getegid
#asm
export _getegid
_getegid:
  mov   eax,#50
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL acct                    51  1 */

#ifdef L_acct
#asm
export _acct
_acct:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#51
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL ioctl                   54  3 */

#ifdef L_ioctl
#asm
export _ioctl
_ioctl:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#54
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL fcntl                   55  3 */

#ifdef L_fcntl
#asm
export _fcntl
_fcntl:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#55
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setpgid                 57  2 */

#ifdef L_setpgid
#asm
export _setpgid
_setpgid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#57
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL ulimit                  58  2 */

#ifdef L_ulimit
#asm
export _ulimit
_ulimit:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#58
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL umask                   60  1 */

#ifdef L_umask
#asm
export _umask
_umask:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#60
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL chroot                  61  1 */

#ifdef L_chroot
#asm
export _chroot
_chroot:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#61
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL dv32_ustat              62  2	* has correct args for 32bit dev_t */

#ifdef L___dv32_ustat
#asm
export ___dv32_ustat
___dv32_ustat:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#62
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL dup2                    63  2 */

#ifdef L_dup2
#asm
export _dup2
_dup2:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#63
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getppid                 64  0 */

#ifdef L_getppid
#asm
export _getppid
_getppid:
  mov   eax,#64
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getpgrp                 65  0 */

#ifdef L_getpgrp
#asm
export _getpgrp
_getpgrp:
  mov   eax,#65
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setsid                  66  0 */

#ifdef L_setsid
#asm
export _setsid
_setsid:
  mov   eax,#66
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sigaction               67  3 */

#ifdef L_sigaction
#asm
export _sigaction
_sigaction:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#67
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL siggetmask              68  0 */

#ifdef L_siggetmask
#asm
export _siggetmask
_siggetmask:
  mov   eax,#68
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sigsetmask              69  1 */

#ifdef L_sigsetmask
#asm
export _sigsetmask
_sigsetmask:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#69
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setreuid                70  2 */

#ifdef L_setreuid
#asm
export _setreuid
_setreuid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#70
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setregid                71  2 */

#ifdef L_setregid
#asm
export _setregid
_setregid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#71
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sigsuspend              72  1 */

#ifdef L_sigsuspend
#asm
export _sigsuspend
_sigsuspend:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#72
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sigpending              73  1 */

#ifdef L_sigpending
#asm
export _sigpending
_sigpending:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#73
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sethostname             74  2 */

#ifdef L_sethostname
#asm
export _sethostname
_sethostname:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#74
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setrlimit               75  2 */

#ifdef L_setrlimit
#asm
export _setrlimit
_setrlimit:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#75
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getrlimit               76  2 */

#ifdef L_getrlimit
#asm
export _getrlimit
_getrlimit:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#76
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getrusage               77  2 */

#ifdef L_getrusage
#asm
export _getrusage
_getrusage:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#77
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL gettimeofday            78  2 */

#ifdef L_gettimeofday
#asm
export _gettimeofday
_gettimeofday:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#78
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL settimeofday            79  2 */

#ifdef L_settimeofday
#asm
export _settimeofday
_settimeofday:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#79
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getgroups               80  2 */

#ifdef L_getgroups
#asm
export _getgroups
_getgroups:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#80
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setgroups               81  2 */

#ifdef L_setgroups
#asm
export _setgroups
_setgroups:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#81
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL select                  82  1	* select's arg is &arg1 */

#ifdef L___select
#asm
export ___select
___select:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#82
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL symlink                 83  2 */

#ifdef L_symlink
#asm
export _symlink
_symlink:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#83
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL readlink                85  3 */

#ifdef L_readlink
#asm
export _readlink
_readlink:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#85
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL uselib                  86  1 */

#ifdef L_uselib
#asm
export _uselib
_uselib:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#86
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL swapon                  87  2 */

#ifdef L_swapon
#asm
export _swapon
_swapon:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#87
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL reboot                  88  3 */

#ifdef L_reboot
#asm
export _reboot
_reboot:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#88
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL readdir                 89  3	* takes the fd not a ddptr */

#ifdef L___readdir
#asm
export ___readdir
___readdir:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#89
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL mmap                    90  1	* is a pointer to a buffer with the 6 args. */

#ifdef L___mmap
#asm
export ___mmap
___mmap:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#90
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL munmap                  91  2 */

#ifdef L_munmap
#asm
export _munmap
_munmap:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#91
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL truncate                92  2 */

#ifdef L_truncate
#asm
export _truncate
_truncate:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#92
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL ftruncate               93  2 */

#ifdef L_ftruncate
#asm
export _ftruncate
_ftruncate:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#93
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL fchmod                  94  2 */

#ifdef L_fchmod
#asm
export _fchmod
_fchmod:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#94
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL fchown                  95  2 */

#ifdef L_fchown
#asm
export _fchown
_fchown:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#95
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getpriority             96  2 */

#ifdef L_getpriority
#asm
export _getpriority
_getpriority:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#96
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setpriority             97  3 */

#ifdef L_setpriority
#asm
export _setpriority
_setpriority:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#97
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL statfs                  99  2 */

#ifdef L_statfs
#asm
export _statfs
_statfs:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#99
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL fstatfs                 100 2 */

#ifdef L_fstatfs
#asm
export _fstatfs
_fstatfs:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#100
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL ioperm                  101 3 */

#ifdef L_ioperm
#asm
export _ioperm
_ioperm:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#101
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL socketcall              102 2	* this is a lib internal for socket stuff */

#ifdef L___socketcall
#asm
export ___socketcall
___socketcall:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#102
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setitimer               104 3 */

#ifdef L_setitimer
#asm
export _setitimer
_setitimer:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#104
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getitimer               105 2 */

#ifdef L_getitimer
#asm
export _getitimer
_getitimer:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#105
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL dv32_stat               106 2	* has correct args for 32 bit dev_t */

#ifdef L___dv32_stat
#asm
export ___dv32_stat
___dv32_stat:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#106
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL dv32_lstat              107 2	* has correct args for 32 bit dev_t */

#ifdef L___dv32_lstat
#asm
export ___dv32_lstat
___dv32_lstat:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#107
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL dv32_fstat              108 2	* has correct args for 32 bit dev_t */

#ifdef L___dv32_fstat
#asm
export ___dv32_fstat
___dv32_fstat:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#108
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL iopl                    110 1 */

#ifdef L_iopl
#asm
export _iopl
_iopl:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#110
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL vhangup                 111 0 */

#ifdef L_vhangup
#asm
export _vhangup
_vhangup:
  mov   eax,#111
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL vm86                    113 1	* warning now vm86old */

#ifdef L___vm86
#asm
export ___vm86
___vm86:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#113
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL wait4                   114 4 */

#ifdef L_wait4
#asm
export _wait4
_wait4:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
  push  esi
  mov   esi,[esp+16]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
  push  esi
  mov   esi,[esp+20]
#endif
  mov   eax,#114
  int   $80
  pop   esi
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL swapoff                 115 1 */

#ifdef L_swapoff
#asm
export _swapoff
_swapoff:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#115
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sysinfo                 116 1 */

#ifdef L_sysinfo
#asm
export _sysinfo
_sysinfo:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#116
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL ipc                     117 5	* sysv ipc entry point */

#ifdef L___ipc
#asm
export ___ipc
___ipc:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
  push  esi
  mov   esi,[esp+16]
  push  edi
  mov   edi,[esp+24]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
  push  esi
  mov   esi,[esp+20]
  push  edi
  mov   edi,[esp+28]
#endif
  mov   eax,#117
  int   $80
  pop   edi
  pop   esi
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL fsync                   118 1 */

#ifdef L_fsync
#asm
export _fsync
_fsync:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#118
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sigreturn               119 1	* signal internal */

#ifdef L___sigreturn
#asm
export ___sigreturn
___sigreturn:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#119
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL clone                   120 2 */

#ifdef L_clone
#asm
export _clone
_clone:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#120
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setdomainname           121 2 */

#ifdef L_setdomainname
#asm
export _setdomainname
_setdomainname:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#121
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL uname                   122 1 */

#ifdef L_uname
#asm
export _uname
_uname:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#122
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL adjtimex                124 1 */

#ifdef L_adjtimex
#asm
export _adjtimex
_adjtimex:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#124
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL mprotect                125 3 */

#ifdef L_mprotect
#asm
export _mprotect
_mprotect:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#125
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sigprocmask             126 3 */

#ifdef L_sigprocmask
#asm
export _sigprocmask
_sigprocmask:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#126
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getpgid                 132 1 */

#ifdef L_getpgid
#asm
export _getpgid
_getpgid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#132
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL fchdir                  133 1 */

#ifdef L_fchdir
#asm
export _fchdir
_fchdir:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#133
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL bdflush                 134 2 */

#ifdef L_bdflush
#asm
export _bdflush
_bdflush:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#134
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL sysfs                   135 3 */

#ifdef L_sysfs
#asm
export _sysfs
_sysfs:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#135
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL personality             136 1	* linux specific. */

#ifdef L___personality
#asm
export ___personality
___personality:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#136
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setfsuid                138 1 */

#ifdef L_setfsuid
#asm
export _setfsuid
_setfsuid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#138
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL setfsgid                139 1 */

#ifdef L_setfsgid
#asm
export _setfsgid
_setfsgid:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
#else
  mov   ebx,[esp+4]
#endif
  mov   eax,#139
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL getdents                141 3	* new style readdir ? */

#ifdef L___getdents
#asm
export ___getdents
___getdents:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
  mov   edx,[esp+8]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
  mov   edx,[esp+12]
#endif
  mov   eax,#141
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL flock                   143 2 */

#ifdef L_flock
#asm
export _flock
_flock:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#143
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

/* CALL nanosleep               162 2 */

#ifdef L_nanosleep
#asm
export _nanosleep
_nanosleep:
#if __FIRST_ARG_IN_AX__
  mov   ebx,eax
  mov   ecx,[esp+4]
#else
  mov   ebx,[esp+4]
  mov   ecx,[esp+8]
#endif
  mov   eax,#162
  int   $80
  test  eax,eax
  jl   syscall_err
  ret
syscall_err:
  neg   eax
  mov   [_errno],eax
  mov   eax,#-1
  ret
#endasm
#endif

#endif /* __AS386_32__ */

#endif /* __MSDOS__ */

