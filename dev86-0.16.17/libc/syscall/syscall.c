/* Copyright (C) 1995,1996 Robert de Bath <rdebath@cix.compulink.co.uk>
 * This file is part of the Linux-8086 C library and is distributed
 * under the GNU Library General Public License.
 * 
 * This file is automatically generated */

/* Standard start */


#ifndef __MSDOS__
#ifdef __AS386_16__
#asm
  .text
  .even
#endasm

/* Shared system call code */

#ifdef L___syscall
#asm
#if __FIRST_ARG_IN_AX__
export sys_call3
sys_call3:
  mov   bx,sp
  mov   cx,[bx+2]
  mov   bx,[bx+4]
  xchg  ax,bx
  xchg  ax,dx
  jmp   sys_call0

export sys_call2
sys_call2:
  mov   bx,sp
  mov   cx,[bx+2]
  mov   bx,ax
  mov   ax,dx
  jmp   sys_call0

export sys_call1
sys_call1:
  mov   bx,ax
  mov   ax,dx
#else
export sys_call3
sys_call3:
  mov   bx,sp
  mov   dx,[bx+6]
  mov   cx,[bx+4]
  mov   bx,[bx+2]
  jmp   sys_call0

export sys_call2
sys_call2:
  mov   bx,sp
  mov   cx,[bx+4]
  mov   bx,[bx+2]
  jmp   sys_call0

export sys_call1
sys_call1:
  mov   bx,sp
  mov   bx,[bx+2]
#endif

export sys_call0
sys_call0:
  int   $80
  test  ax,ax
  jge  syscall_ok
  neg   ax
  mov   [_errno],ax
  mov   ax,#-1
syscall_ok:
  ret
#endasm
#endif

/* Shared system call code, syscalls with 4/5 args */

#ifdef L___syscall4
#asm
#if __FIRST_ARG_IN_AX__
export sys_call4
sys_call4:
export sys_call5
sys_call5:
  mov   bx,sp
  push  si
  mov   si,[bx+8]
  push  di
  mov   di,[bx+6]
  mov   cx,[bx+2]
  mov   bx,[bx+4]
  xchg  ax,bx
  xchg  ax,dx
#else
export sys_call4
sys_call4:
export sys_call5
sys_call5:
  mov   bx,sp
  push  si
  mov   si,[bx+10]
  push  di
  mov   di,[bx+8]
  mov   dx,[bx+6]
  mov   cx,[bx+4]
  mov   bx,[bx+2]
#endif

  int   $80
  pop   di
  pop   si
  test  ax,ax
  jge  syscall_ok
  neg   ax
  mov   [_errno],ax
  mov   ax,#-1
syscall_ok:
  ret
#endasm
#endif

/* CALL exit		+1	1	* c exit does stdio, _exit in crt0 */

#ifdef L___exit
#asm
export ___exit
___exit:
#if __FIRST_ARG_IN_AX__
  mov   dx,#1
#else
  mov   ax,#1
#endif
  br    sys_call1
#endasm
#endif

/* CALL fork		+2	0	  */

#ifdef L_fork
#asm
export _fork
_fork:
  mov   ax,#2
  br    sys_call0
#endasm
#endif

/* CALL read		+3	3	  */

#ifdef L_read
#asm
export _read
_read:
#if __FIRST_ARG_IN_AX__
  mov   dx,#3
#else
  mov   ax,#3
#endif
  br    sys_call3
#endasm
#endif

/* CALL write		+4	3	  */

#ifdef L_write
#asm
export _write
_write:
#if __FIRST_ARG_IN_AX__
  mov   dx,#4
#else
  mov   ax,#4
#endif
  br    sys_call3
#endasm
#endif

/* CALL open		+5	3	  */

#ifdef L_open
#asm
export _open
_open:
#if __FIRST_ARG_IN_AX__
  mov   dx,#5
#else
  mov   ax,#5
#endif
  br    sys_call3
#endasm
#endif

/* CALL close		+6	1	  */

#ifdef L_close
#asm
export _close
_close:
#if __FIRST_ARG_IN_AX__
  mov   dx,#6
#else
  mov   ax,#6
#endif
  br    sys_call1
#endasm
#endif

/* CALL wait4		+7	4 */

#ifdef L_wait4
#asm
export _wait4
_wait4:
#if __FIRST_ARG_IN_AX__
  mov   bx,sp
  push  di
  mov   di,[bx+6]
  mov   dx,[bx+4]
  mov   cx,[bx+2]
  mov   bx,ax
#else
  mov   bx,sp
  push  di
  mov   di,[bx+8]
  mov   dx,[bx+6]
  mov   cx,[bx+4]
  mov   bx,[bx+2]
#endif
  mov   ax,#7
  int   $80
  pop   di
  test  ax,ax
  jl   syscall_err
  ret
syscall_err:
  neg   ax
  mov   [_errno],ax
  mov   ax,#-1
  ret
#endasm
#endif

/* CALL link		+9	2	  */

#ifdef L_link
#asm
export _link
_link:
#if __FIRST_ARG_IN_AX__
  mov   dx,#9
#else
  mov   ax,#9
#endif
  br    sys_call2
#endasm
#endif

/* CALL unlink		+10	1	  */

#ifdef L_unlink
#asm
export _unlink
_unlink:
#if __FIRST_ARG_IN_AX__
  mov   dx,#10
#else
  mov   ax,#10
#endif
  br    sys_call1
#endasm
#endif

/* CALL execve		+11	3	* execve minix style */

#ifdef L___execve
#asm
export ___execve
___execve:
#if __FIRST_ARG_IN_AX__
  mov   dx,#11
#else
  mov   ax,#11
#endif
  br    sys_call3
#endasm
#endif

/* CALL chdir		+12	1	  */

#ifdef L_chdir
#asm
export _chdir
_chdir:
#if __FIRST_ARG_IN_AX__
  mov   dx,#12
#else
  mov   ax,#12
#endif
  br    sys_call1
#endasm
#endif

/* CALL mknod		+14	3	  */

#ifdef L_mknod
#asm
export _mknod
_mknod:
#if __FIRST_ARG_IN_AX__
  mov   dx,#14
#else
  mov   ax,#14
#endif
  br    sys_call3
#endasm
#endif

/* CALL chmod		+15	2	  */

#ifdef L_chmod
#asm
export _chmod
_chmod:
#if __FIRST_ARG_IN_AX__
  mov   dx,#15
#else
  mov   ax,#15
#endif
  br    sys_call2
#endasm
#endif

/* CALL chown		+16	3	  */

#ifdef L_chown
#asm
export _chown
_chown:
#if __FIRST_ARG_IN_AX__
  mov   dx,#16
#else
  mov   ax,#16
#endif
  br    sys_call3
#endasm
#endif

/* CALL brk		+17	1	* this is only to tell the system */

#ifdef L___brk
#asm
export ___brk
___brk:
#if __FIRST_ARG_IN_AX__
  mov   dx,#17
#else
  mov   ax,#17
#endif
  br    sys_call1
#endasm
#endif

/* CALL stat		+18	2	  */

#ifdef L_stat
#asm
export _stat
_stat:
#if __FIRST_ARG_IN_AX__
  mov   dx,#18
#else
  mov   ax,#18
#endif
  br    sys_call2
#endasm
#endif

/* CALL lseek		+19	3	* nb 2nd arg is an io ptr to long not a long. */

#ifdef L___lseek
#asm
export ___lseek
___lseek:
#if __FIRST_ARG_IN_AX__
  mov   dx,#19
#else
  mov   ax,#19
#endif
  br    sys_call3
#endasm
#endif

/* CALL getpid		+20	1	* this gets both pid & ppid */

#ifdef L___getpid
#asm
export ___getpid
___getpid:
#if __FIRST_ARG_IN_AX__
  mov   dx,#20
#else
  mov   ax,#20
#endif
  br    sys_call1
#endasm
#endif

/* CALL mount		+21	5	  */

#ifdef L_mount
#asm
export _mount
_mount:
#if __FIRST_ARG_IN_AX__
  mov   bx,sp
  push  si
  mov   si,[bx+8]
  push  di
  mov   di,[bx+6]
  mov   dx,[bx+4]
  mov   cx,[bx+2]
  mov   bx,ax
#else
  mov   bx,sp
  push  si
  mov   si,[bx+10]
  push  di
  mov   di,[bx+8]
  mov   dx,[bx+6]
  mov   cx,[bx+4]
  mov   bx,[bx+2]
#endif
  mov   ax,#21
  int   $80
  pop   di
  pop   si
  test  ax,ax
  jl   syscall_err
  ret
syscall_err:
  neg   ax
  mov   [_errno],ax
  mov   ax,#-1
  ret
#endasm
#endif

/* CALL umount		+22	1	  */

#ifdef L_umount
#asm
export _umount
_umount:
#if __FIRST_ARG_IN_AX__
  mov   dx,#22
#else
  mov   ax,#22
#endif
  br    sys_call1
#endasm
#endif

/* CALL setuid		+23	1	  */

#ifdef L_setuid
#asm
export _setuid
_setuid:
#if __FIRST_ARG_IN_AX__
  mov   dx,#23
#else
  mov   ax,#23
#endif
  br    sys_call1
#endasm
#endif

/* CALL getuid		+24	1	* this gets both uid and euid */

#ifdef L___getuid
#asm
export ___getuid
___getuid:
#if __FIRST_ARG_IN_AX__
  mov   dx,#24
#else
  mov   ax,#24
#endif
  br    sys_call1
#endasm
#endif

/* CALL alarm		27	2 */

#ifdef L_alarm
#asm
export _alarm
_alarm:
#if __FIRST_ARG_IN_AX__
  mov   dx,#27
#else
  mov   ax,#27
#endif
  br    sys_call2
#endasm
#endif

/* CALL fstat		+28	2	  */

#ifdef L_fstat
#asm
export _fstat
_fstat:
#if __FIRST_ARG_IN_AX__
  mov   dx,#28
#else
  mov   ax,#28
#endif
  br    sys_call2
#endasm
#endif

/* CALL pause		29	0	  */

#ifdef L_pause
#asm
export _pause
_pause:
  mov   ax,#29
  br    sys_call0
#endasm
#endif

/* CALL utime		+30	2	  */

#ifdef L_utime
#asm
export _utime
_utime:
#if __FIRST_ARG_IN_AX__
  mov   dx,#30
#else
  mov   ax,#30
#endif
  br    sys_call2
#endasm
#endif

/* CALL chroot		+31	1 */

#ifdef L_chroot
#asm
export _chroot
_chroot:
#if __FIRST_ARG_IN_AX__
  mov   dx,#31
#else
  mov   ax,#31
#endif
  br    sys_call1
#endasm
#endif

/* CALL vfork		+32	0 */

#ifdef L_vfork
#asm
export _vfork
_vfork:
  mov   ax,#32
  br    sys_call0
#endasm
#endif

/* CALL access		+33	2	  */

#ifdef L_access
#asm
export _access
_access:
#if __FIRST_ARG_IN_AX__
  mov   dx,#33
#else
  mov   ax,#33
#endif
  br    sys_call2
#endasm
#endif

/* CALL nice		34	1 */

#ifdef L_nice
#asm
export _nice
_nice:
#if __FIRST_ARG_IN_AX__
  mov   dx,#34
#else
  mov   ax,#34
#endif
  br    sys_call1
#endasm
#endif

/* CALL sleep		35	1 */

#ifdef L_sleep
#asm
export _sleep
_sleep:
#if __FIRST_ARG_IN_AX__
  mov   dx,#35
#else
  mov   ax,#35
#endif
  br    sys_call1
#endasm
#endif

/* CALL sync		+36	0	  */

#ifdef L_sync
#asm
export _sync
_sync:
  mov   ax,#36
  br    sys_call0
#endasm
#endif

/* CALL kill		+37	2	  */

#ifdef L_kill
#asm
export _kill
_kill:
#if __FIRST_ARG_IN_AX__
  mov   dx,#37
#else
  mov   ax,#37
#endif
  br    sys_call2
#endasm
#endif

/* CALL rename		+38	2	  */

#ifdef L_rename
#asm
export _rename
_rename:
#if __FIRST_ARG_IN_AX__
  mov   dx,#38
#else
  mov   ax,#38
#endif
  br    sys_call2
#endasm
#endif

/* CALL mkdir		+39	2	  */

#ifdef L_mkdir
#asm
export _mkdir
_mkdir:
#if __FIRST_ARG_IN_AX__
  mov   dx,#39
#else
  mov   ax,#39
#endif
  br    sys_call2
#endasm
#endif

/* CALL rmdir		+40	1	  */

#ifdef L_rmdir
#asm
export _rmdir
_rmdir:
#if __FIRST_ARG_IN_AX__
  mov   dx,#40
#else
  mov   ax,#40
#endif
  br    sys_call1
#endasm
#endif

/* CALL dup		+41	1	. there is a fcntl lib function too. */

#ifdef L_dup
#asm
export _dup
_dup:
#if __FIRST_ARG_IN_AX__
  mov   dx,#41
#else
  mov   ax,#41
#endif
  br    sys_call1
#endasm
#endif

/* CALL pipe		+42	1	  */

#ifdef L_pipe
#asm
export _pipe
_pipe:
#if __FIRST_ARG_IN_AX__
  mov   dx,#42
#else
  mov   ax,#42
#endif
  br    sys_call1
#endasm
#endif

/* CALL times		43	2	* 2nd arg is pointer for long ret val. */

#ifdef L___times
#asm
export ___times
___times:
#if __FIRST_ARG_IN_AX__
  mov   dx,#43
#else
  mov   ax,#43
#endif
  br    sys_call2
#endasm
#endif

/* CALL dup2		+45	2 */

#ifdef L_dup2
#asm
export _dup2
_dup2:
#if __FIRST_ARG_IN_AX__
  mov   dx,#45
#else
  mov   ax,#45
#endif
  br    sys_call2
#endasm
#endif

/* CALL setgid		+46	1	  */

#ifdef L_setgid
#asm
export _setgid
_setgid:
#if __FIRST_ARG_IN_AX__
  mov   dx,#46
#else
  mov   ax,#46
#endif
  br    sys_call1
#endasm
#endif

/* CALL getgid		47	1	* this gets both gid and egid */

#ifdef L___getgid
#asm
export ___getgid
___getgid:
#if __FIRST_ARG_IN_AX__
  mov   dx,#47
#else
  mov   ax,#47
#endif
  br    sys_call1
#endasm
#endif

/* CALL signal		+48	2	* have put the despatch table in user space. */

#ifdef L___signal
#asm
export ___signal
___signal:
#if __FIRST_ARG_IN_AX__
  mov   dx,#48
#else
  mov   ax,#48
#endif
  br    sys_call2
#endasm
#endif

/* CALL fcntl		+50	3	  */

#ifdef L_fcntl
#asm
export _fcntl
_fcntl:
#if __FIRST_ARG_IN_AX__
  mov   dx,#50
#else
  mov   ax,#50
#endif
  br    sys_call3
#endasm
#endif

/* CALL ioctl		+54	3	. make this and fcntl the same ? */

#ifdef L_ioctl
#asm
export _ioctl
_ioctl:
#if __FIRST_ARG_IN_AX__
  mov   dx,#54
#else
  mov   ax,#54
#endif
  br    sys_call3
#endasm
#endif

/* CALL reboot		+55	3	. the magic number is 0xfee1,0xdead,... */

#ifdef L_reboot
#asm
export _reboot
_reboot:
#if __FIRST_ARG_IN_AX__
  mov   dx,#55
#else
  mov   ax,#55
#endif
  br    sys_call3
#endasm
#endif

/* CALL lstat		+57	2 */

#ifdef L_lstat
#asm
export _lstat
_lstat:
#if __FIRST_ARG_IN_AX__
  mov   dx,#57
#else
  mov   ax,#57
#endif
  br    sys_call2
#endasm
#endif

/* CALL symlink		+58	2 */

#ifdef L_symlink
#asm
export _symlink
_symlink:
#if __FIRST_ARG_IN_AX__
  mov   dx,#58
#else
  mov   ax,#58
#endif
  br    sys_call2
#endasm
#endif

/* CALL readlink	+59	3 */

#ifdef L_readlink
#asm
export _readlink
_readlink:
#if __FIRST_ARG_IN_AX__
  mov   dx,#59
#else
  mov   ax,#59
#endif
  br    sys_call3
#endasm
#endif

/* CALL umask		+60	1	  */

#ifdef L_umask
#asm
export _umask
_umask:
#if __FIRST_ARG_IN_AX__
  mov   dx,#60
#else
  mov   ax,#60
#endif
  br    sys_call1
#endasm
#endif

/* CALL settimeofday	+61	2 */

#ifdef L_settimeofday
#asm
export _settimeofday
_settimeofday:
#if __FIRST_ARG_IN_AX__
  mov   dx,#61
#else
  mov   ax,#61
#endif
  br    sys_call2
#endasm
#endif

/* CALL gettimeofday	+62	2 */

#ifdef L_gettimeofday
#asm
export _gettimeofday
_gettimeofday:
#if __FIRST_ARG_IN_AX__
  mov   dx,#62
#else
  mov   ax,#62
#endif
  br    sys_call2
#endasm
#endif

/* CALL select          +63     5	. 5 paramaters is possible */

#ifdef L_select
#asm
export _select
_select:
#if __FIRST_ARG_IN_AX__
  mov   bx,sp
  push  si
  mov   si,[bx+8]
  push  di
  mov   di,[bx+6]
  mov   dx,[bx+4]
  mov   cx,[bx+2]
  mov   bx,ax
#else
  mov   bx,sp
  push  si
  mov   si,[bx+10]
  push  di
  mov   di,[bx+8]
  mov   dx,[bx+6]
  mov   cx,[bx+4]
  mov   bx,[bx+2]
#endif
  mov   ax,#63
  int   $80
  pop   di
  pop   si
  test  ax,ax
  jl   syscall_err
  ret
syscall_err:
  neg   ax
  mov   [_errno],ax
  mov   ax,#-1
  ret
#endasm
#endif

/* CALL readdir		+64	3	* */

#ifdef L___readdir
#asm
export ___readdir
___readdir:
#if __FIRST_ARG_IN_AX__
  mov   dx,#64
#else
  mov   ax,#64
#endif
  br    sys_call3
#endasm
#endif

/* CALL fchown		+66	3 */

#ifdef L_fchown
#asm
export _fchown
_fchown:
#if __FIRST_ARG_IN_AX__
  mov   dx,#66
#else
  mov   ax,#66
#endif
  br    sys_call3
#endasm
#endif

/* CALL dlload		+67	2 */

#ifdef L_dlload
#asm
export _dlload
_dlload:
#if __FIRST_ARG_IN_AX__
  mov   dx,#67
#else
  mov   ax,#67
#endif
  br    sys_call2
#endasm
#endif

/* CALL setsid		+68	0 */

#ifdef L_setsid
#asm
export _setsid
_setsid:
  mov   ax,#68
  br    sys_call0
#endasm
#endif

/* CALL socket		+69	3 */

#ifdef L_socket
#asm
export _socket
_socket:
#if __FIRST_ARG_IN_AX__
  mov   dx,#69
#else
  mov   ax,#69
#endif
  br    sys_call3
#endasm
#endif

/* CALL bind		+70	3 */

#ifdef L_bind
#asm
export _bind
_bind:
#if __FIRST_ARG_IN_AX__
  mov   dx,#70
#else
  mov   ax,#70
#endif
  br    sys_call3
#endasm
#endif

/* CALL listen		+71	2 */

#ifdef L_listen
#asm
export _listen
_listen:
#if __FIRST_ARG_IN_AX__
  mov   dx,#71
#else
  mov   ax,#71
#endif
  br    sys_call2
#endasm
#endif

/* CALL accept		+72	3 */

#ifdef L_accept
#asm
export _accept
_accept:
#if __FIRST_ARG_IN_AX__
  mov   dx,#72
#else
  mov   ax,#72
#endif
  br    sys_call3
#endasm
#endif

/* CALL connect		+73	3 */

#ifdef L_connect
#asm
export _connect
_connect:
#if __FIRST_ARG_IN_AX__
  mov   dx,#73
#else
  mov   ax,#73
#endif
  br    sys_call3
#endasm
#endif

/* CALL knlvsn          +74     1	= config_sys_version */

#ifdef L_knlvsn
#asm
export _knlvsn
_knlvsn:
#if __FIRST_ARG_IN_AX__
  mov   dx,#74
#else
  mov   ax,#74
#endif
  br    sys_call1
#endasm
#endif

#endif /* __AS386_16__ */

#endif /* __MSDOS__ */

